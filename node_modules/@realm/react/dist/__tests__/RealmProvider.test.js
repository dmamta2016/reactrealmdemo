////////////////////////////////////////////////////////////////////////////
//
// Copyright 2021 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
import React, { useRef, useState } from "react";
import Realm from "realm";
import "@testing-library/jest-native/extend-expect";
import { createRealmContext } from "..";
import { mergeRealmConfiguration, areConfigurationsIdentical } from "../RealmProvider";
import { View, Button, Text } from "react-native";
import { render, fireEvent, waitFor, renderHook, act } from "@testing-library/react-native";
const dogSchema = {
    name: "dog",
    primaryKey: "_id",
    properties: {
        _id: "int",
        name: "string",
    },
};
const catSchema = {
    name: "cat",
    primaryKey: "_id",
    properties: {
        _id: "int",
        name: "string",
    },
};
const { RealmProvider, useRealm } = createRealmContext({
    schema: [dogSchema],
    inMemory: true,
    path: "testArtifacts/realm-provider.realm",
});
const EmptyRealmContext = createRealmContext();
describe("RealmProvider", () => {
    afterEach(() => {
        Realm.clearTestState();
    });
    it("returns the configured realm with useRealm and closes on unmount", async () => {
        const wrapper = ({ children }) => React.createElement(RealmProvider, null, children);
        const { result, unmount } = renderHook(() => useRealm(), { wrapper });
        await waitFor(() => expect(result.current).not.toBe(null));
        const realm = result.current;
        expect(realm).not.toBe(null);
        expect(realm.schema[0].name).toBe("dog");
        unmount();
        expect(realm.isClosed).toBe(true);
    });
    it("will override the the configuration provided in createRealmContext", async () => {
        const wrapper = ({ children }) => (React.createElement(RealmProvider, { schema: [catSchema] }, children));
        const { result } = renderHook(() => useRealm(), { wrapper });
        await waitFor(() => expect(result.current).not.toBe(null));
        const realm = result.current;
        expect(realm).not.toBe(null);
        expect(realm.schema[0].name).toBe("cat");
    });
    it("can be used with an initially empty realm context", async () => {
        const wrapper = ({ children }) => (React.createElement(EmptyRealmContext.RealmProvider, { schema: [catSchema] }, children));
        const { result } = renderHook(() => EmptyRealmContext.useRealm(), { wrapper });
        await waitFor(() => expect(result.current).not.toBe(null));
        const realm = result.current;
        expect(realm).not.toBe(null);
        expect(realm.schema[0].name).toBe("cat");
    });
    it("can be provided in multiple parts of an application", async () => {
        const RealmComponent = () => {
            const realm = useRealm();
            return (React.createElement(Button, { testID: "action", title: "toggle", onPress: () => realm.write(() => {
                    realm.create("dog", { _id: new Date().getTime(), name: "Rex" });
                }) }));
        };
        const App = () => {
            const [toggleComponent, setToggleComponent] = useState(true);
            return (React.createElement(React.Fragment, null,
                React.createElement(View, { testID: "firstRealmProvider" },
                    React.createElement(RealmProvider, null,
                        React.createElement(RealmComponent, null))),
                toggleComponent && (React.createElement(View, { testID: "secondRealmProvider" },
                    React.createElement(RealmProvider, null,
                        React.createElement(View, null)))),
                React.createElement(Button, { testID: "toggle", title: "toggle", onPress: () => setToggleComponent(!toggleComponent) })));
        };
        const { getByTestId } = render(React.createElement(App, null));
        const secondRealmProvider = getByTestId("secondRealmProvider");
        const toggleComponent = getByTestId("toggle");
        const actionComponent = await waitFor(() => getByTestId("action"));
        expect(secondRealmProvider).not.toBeEmptyElement();
        await act(async () => {
            fireEvent.press(toggleComponent);
            await new Promise((resolve) => setTimeout(resolve, 0));
        });
        expect(() => getByTestId("secondRealmProvider")).toThrow("Unable to find an element with testID: secondRealmProvider");
        // This is actually a bug that we need to fix on a deeper level
        await act(async () => {
            expect(() => fireEvent.press(actionComponent)).toThrow("Cannot access realm that has been closed.");
        });
    });
    it("handle state changes to its configuration", async () => {
        const RealmComponent = () => {
            const realm = useRealm();
            return React.createElement(Text, { testID: "schemaName" }, realm.schema[0].name);
        };
        const App = () => {
            const [schema, setSchema] = useState(dogSchema);
            return (React.createElement(React.Fragment, null,
                React.createElement(View, { testID: "firstRealmProvider" },
                    React.createElement(RealmProvider, { schema: [schema] },
                        React.createElement(RealmComponent, null))),
                React.createElement(Button, { testID: "changeSchema", title: "change schema", onPress: () => setSchema(catSchema) })));
        };
        const { getByTestId } = render(React.createElement(App, null));
        const schemaNameContainer = await waitFor(() => getByTestId("schemaName"));
        const changeSchemaButton = getByTestId("changeSchema");
        expect(schemaNameContainer).toHaveTextContent("dog");
        await act(async () => {
            fireEvent.press(changeSchemaButton);
            await new Promise((resolve) => setTimeout(resolve, 0));
        });
        // Changing the realm provider configuration will cause a comlete new remount
        // of the child component.  Therefore it must be retreived again
        const newSchemaNameContainer = getByTestId("schemaName");
        expect(newSchemaNameContainer).toHaveTextContent("cat");
    });
    it("can access realm through realmRef as a forwarded ref", async () => {
        const RealmComponent = () => {
            const realm = useRealm();
            return React.createElement(Text, { testID: "schemaName" }, realm.schema[0].name);
        };
        const App = () => {
            const realmRef = useRef(null);
            const [path, setPath] = useState("");
            return (React.createElement(React.Fragment, null,
                React.createElement(View, { testID: "firstRealmProvider" },
                    React.createElement(RealmProvider, { realmRef: realmRef, schema: [dogSchema], path: "testPath.realm" },
                        React.createElement(RealmComponent, null))),
                React.createElement(Button, { testID: "toggleRefPath", title: "toggle ref path", onPress: () => setPath(realmRef?.current?.path ?? "") }),
                realmRef.current && React.createElement(Text, { testID: "realmRefPath" }, path)));
        };
        const { getByTestId, queryByTestId } = render(React.createElement(App, null));
        await waitFor(() => getByTestId("schemaName"));
        const toggleRefPath = getByTestId("toggleRefPath");
        // Wait a tick for the RealmProvider to set the reference and then call a function that uses the ref
        await act(async () => {
            await new Promise((resolve) => setTimeout(resolve, 0));
            fireEvent.press(toggleRefPath);
        });
        const realmRefPathText = await waitFor(() => queryByTestId("realmRefPath"));
        expect(realmRefPathText).toHaveTextContent("testPath.realm");
    });
    describe("initially renders a fallback, until realm exists", () => {
        it("as a component", async () => {
            const App = () => {
                return (React.createElement(RealmProvider, { fallback: () => React.createElement(View, { testID: "fallbackContainer" }) },
                    React.createElement(View, { testID: "testContainer" })));
            };
            const { queryByTestId } = render(React.createElement(App, null));
            expect(queryByTestId("fallbackContainer")).not.toBeNull();
            expect(queryByTestId("testContainer")).toBeNull();
            await waitFor(() => queryByTestId("testContainer"));
            expect(queryByTestId("fallbackContainer")).toBeNull();
            expect(queryByTestId("testContainer")).not.toBeNull();
        });
        it("as an element", async () => {
            const Fallback = React.createElement(View, { testID: "fallbackContainer" });
            const App = () => {
                return (React.createElement(RealmProvider, { fallback: Fallback },
                    React.createElement(View, { testID: "testContainer" })));
            };
            const { queryByTestId } = render(React.createElement(App, null));
            expect(queryByTestId("fallbackContainer")).not.toBeNull();
            expect(queryByTestId("testContainer")).toBeNull();
            await waitFor(() => queryByTestId("testContainer"));
            expect(queryByTestId("fallbackContainer")).toBeNull();
            expect(queryByTestId("testContainer")).not.toBeNull();
        });
    });
});
describe("mergeRealmConfiguration", () => {
    it("merges two realm configurations", () => {
        const configA = { schema: [catSchema], deleteRealmIfMigrationNeeded: true };
        const configB = { sync: { user: {}, partitionValue: "someValue" } };
        const expectedResult = {
            schema: [catSchema],
            deleteRealmIfMigrationNeeded: true,
            sync: { user: {}, partitionValue: "someValue" },
        };
        const result = mergeRealmConfiguration(configA, configB);
        expect(result).toMatchObject(expectedResult);
    });
    it("merge updates to realm configuration", () => {
        let configA = { schema: [catSchema], deleteRealmIfMigrationNeeded: true };
        let configB = { schema: [dogSchema], deleteRealmIfMigrationNeeded: undefined };
        let expectedResult = {
            schema: [dogSchema],
        };
        expect(mergeRealmConfiguration(configA, configB)).toMatchObject(expectedResult);
        configA = { schema: [catSchema], deleteRealmIfMigrationNeeded: true };
        configB = { schema: [catSchema, dogSchema], deleteRealmIfMigrationNeeded: false };
        expectedResult = {
            schema: [catSchema, dogSchema],
            deleteRealmIfMigrationNeeded: false,
        };
        expect(mergeRealmConfiguration(configA, configB)).toMatchObject(expectedResult);
    });
});
describe("areConfigurationsIdentical", () => {
    it("returns false if changes detected", () => {
        let configA = { schema: [catSchema], deleteRealmIfMigrationNeeded: true };
        let configB = { sync: { user: {}, partitionValue: "someValue" } };
        expect(areConfigurationsIdentical(configA, configB)).toBeFalsy();
        configA = {
            schema: [dogSchema, catSchema],
            sync: { user: {}, partitionValue: "otherValue" },
        };
        configB = {
            schema: [dogSchema, catSchema],
            sync: { user: {}, partitionValue: "someValue" },
        };
        expect(areConfigurationsIdentical(configA, configB)).toBeFalsy();
        configA = { schema: [catSchema], deleteRealmIfMigrationNeeded: true };
        configB = {
            schema: [dogSchema, catSchema],
            sync: { user: {}, partitionValue: "someValue" },
        };
        expect(areConfigurationsIdentical(configA, configB)).toBeFalsy();
        configA = { schema: [catSchema], deleteRealmIfMigrationNeeded: true, onMigration: () => undefined };
        configB = { schema: [catSchema], deleteRealmIfMigrationNeeded: true, onMigration: () => undefined };
        expect(areConfigurationsIdentical(configA, configB)).toBeFalsy();
        configA = { schema: [dogSchema, catSchema], deleteRealmIfMigrationNeeded: true };
        configB = { schema: [catSchema, dogSchema], deleteRealmIfMigrationNeeded: true };
        expect(areConfigurationsIdentical(configA, configB)).toBeFalsy();
    });
    it("returns true there are no changes ", () => {
        let configA = { schema: [catSchema], deleteRealmIfMigrationNeeded: true };
        let configB = { schema: [catSchema], deleteRealmIfMigrationNeeded: true };
        expect(areConfigurationsIdentical(configA, configB)).toBeTruthy();
        const onMigration = () => undefined;
        configA = { schema: [catSchema], deleteRealmIfMigrationNeeded: true, onMigration };
        configB = { schema: [catSchema], deleteRealmIfMigrationNeeded: true, onMigration };
        expect(areConfigurationsIdentical(configA, configB)).toBeTruthy();
    });
});
//# sourceMappingURL=RealmProvider.test.js.map