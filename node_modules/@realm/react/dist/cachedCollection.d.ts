import Realm from "realm";
/**
 * Arguments object for {@link cachedCollection}.
 */
declare type CachedCollectionArgs<T> = {
    /**
     * The {@link Realm.Collection} to proxy
     */
    collection: Realm.Collection<T>;
    /**
     * The {@link Realm} instance
     */
    realm: Realm;
    /**
     * Callback which is called whenever an object in the collection changes
     */
    updateCallback: () => void;
    /**
     * Optional Map to be used as the cache. This is used to allow a `sorted` or `filtered`
     * (derived) version of the collection to reuse the same cache, preventing excess new object
     * references being created.
     */
    objectCache?: Map<string, T>;
    /**
     * Optional flag specifying that this is a derived (`sorted` or `filtered`) version of
     * an existing collection, so we should not create or remove listeners or clear the cache
     * when this is torn down.
     */
    isDerived?: boolean;
};
/**
 * Creates a proxy around a {@link Realm.Collection} that will create new {@link Realm.Object}
 * references on any relevant change (update, insert, deletion) and return the same
 * object reference if no changes have occurred since the last access.
 *
 * This makes the {@link Realm.Collection} behaves in an immutable way, as React expects, so
 * that a {@link Realm.Object} can be wrapped in {@link React.memo} to prevent unnecessary
 * rendering (see {@link useQuery} hook).
 *
 * @param args {@link CachedCollectionArgs} object arguments
 * @returns Proxy object wrapping the collection
 */
export declare function createCachedCollection<T extends Realm.Object>({ collection, realm, updateCallback, objectCache, isDerived, }: CachedCollectionArgs<T>): {
    collection: Realm.Collection<T>;
    tearDown: () => void;
};
export {};
//# sourceMappingURL=cachedCollection.d.ts.map