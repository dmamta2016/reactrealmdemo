const numericRegEx = /^-?\d+$/;
function getCacheKey(id) {
    return `${id}`;
}
/**
 * Creates a proxy around a {@link Realm.Collection} that will create new {@link Realm.Object}
 * references on any relevant change (update, insert, deletion) and return the same
 * object reference if no changes have occurred since the last access.
 *
 * This makes the {@link Realm.Collection} behaves in an immutable way, as React expects, so
 * that a {@link Realm.Object} can be wrapped in {@link React.memo} to prevent unnecessary
 * rendering (see {@link useQuery} hook).
 *
 * @param args {@link CachedCollectionArgs} object arguments
 * @returns Proxy object wrapping the collection
 */
export function createCachedCollection({ collection, realm, updateCallback, objectCache = new Map(), isDerived = false, }) {
    const cachedCollectionHandler = {
        get: function (target, key) {
            // Pass functions through
            const value = Reflect.get(target, key);
            if (typeof value === "function") {
                if (key === "sorted" || key === "filtered") {
                    return (...args) => {
                        const col = Reflect.apply(value, target, args);
                        const { collection: newCol } = createCachedCollection({
                            collection: col,
                            realm,
                            updateCallback,
                            objectCache,
                            isDerived: true,
                        });
                        return newCol;
                    };
                }
                return value.bind(target);
            }
            // If the key is not numeric, pass it through
            if (typeof key === "symbol" || !numericRegEx.test(key)) {
                return value;
            }
            // If the key is numeric, check if we have a cached object for this key
            const index = Number(key);
            const object = target[index];
            // If the collection is modeled in a way that objects can be null
            // then we should return null instead of undefined to stay semantically
            // correct
            if (object === null) {
                return null;
            }
            else if (typeof object === "undefined") {
                // If there is no object at this index, return undefined
                return undefined;
            }
            const objectId = object._objectKey();
            const cacheKey = getCacheKey(objectId);
            // If we do, return it...
            if (objectCache.get(cacheKey)) {
                return objectCache.get(cacheKey);
            }
            // If not then this index has either not been accessed before, or has been invalidated due
            // to a modification. Fetch it from the collection and store it in the cache
            objectCache.set(cacheKey, object);
            return object;
        },
    };
    const cachedCollectionResult = new Proxy(collection, cachedCollectionHandler);
    const listenerCallback = (listenerCollection, changes) => {
        if (changes.deletions.length > 0 || changes.insertions.length > 0 || changes.newModifications.length > 0) {
            // TODO: There is currently no way to rebuild the cache key from the changes array for deleted object.
            // Until it is possible, we clear the cache on deletions.
            // Blocking issue: https://github.com/realm/realm-core/issues/5220
            // Possible solutions:
            // a. the listenerCollection is a frozen copy of the collection before the deletion,
            // allowing accessing the _objectKey() using listenerCollection[index]._objectKey()
            // b. the callback provides an array of changed objectIds
            if (changes.deletions.length > 0) {
                objectCache.clear();
            }
            // Item(s) were modified, just clear them from the cache so that we return new instances for them
            changes.newModifications.forEach((index) => {
                const objectId = listenerCollection[index]._objectKey();
                if (objectId) {
                    const cacheKey = getCacheKey(objectId);
                    if (objectCache.has(cacheKey)) {
                        objectCache.delete(cacheKey);
                    }
                }
            });
            updateCallback();
        }
    };
    if (!isDerived) {
        // If we are in a transaction, then push adding the listener to the event loop.  This will allow the write transaction to finish.
        // see https://github.com/realm/realm-js/issues/4375
        if (realm.isInTransaction) {
            setImmediate(() => {
                collection.addListener(listenerCallback);
            });
        }
        else {
            collection.addListener(listenerCallback);
        }
    }
    const tearDown = () => {
        if (!isDerived) {
            collection.removeListener(listenerCallback);
            objectCache.clear();
        }
    };
    return { collection: cachedCollectionResult, tearDown };
}
//# sourceMappingURL=cachedCollection.js.map